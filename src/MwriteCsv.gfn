<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="MwriteCsv" no-data-ok="true" minver="2018a">
<author email="atecon@posteo.de">Artur Tarassow</author>
<version>0.5</version>
<date>2019-12-13</date>
<description>Write matrix to csv file</description>
<tags>C81</tags>
<help>
Written by Artur Tarassow (please ask questions and report bugs on the gretl mailing list if possible).

Source code and test script(s) can be found here:
https://github.com/atecon/MwriteCsv

Writes the matrix X to a csv-file named filename. In case matrix X comprises column labels, these will be treated as header column labels.
If matrix X comprises column and row labels, the latter will be added as a string-valued column at the last position.

If a file filename already exists, it will be overwritten. The return value is 0 on successful completion; if an error occurs, such as the file being unwritable, the return value will be non-zero.

The output file will be written in the currently set &quot;workdir&quot;, unless the filename string contains a full path specification.

Output:		integer
Arguments:	X (matrix)
			filename (string)
			delimiter (string, either ',' or ';', default ';')
---------------------------------------------------------------

Changelog:
- v0.5, December 2019:
    + initial release
</help>
<gretl-function name="MwriteCsv" type="scalar">
 <params count="3">
  <param name="m" type="matrix" const="true"/>
  <param name="filename" type="string">
<description>Path+filename</description>
  </param>
  <param name="store_arguments" type="string" optional="true" const="true">
<description>(untested) Options for 'store' command</description>
  </param>
 </params>
<code>if !valid_filename(filename) || !valid_matrix(m)
  return 1
endif
if !exists(store_arguments)
  string store_arguments = &quot;&quot;
endif
# Addings obs cannot be put into a separate function (added obs would get lost)
scalar Tlocal = rows(m)
if Tlocal &lt;= $tmax
  smpl 1 Tlocal
else
  smpl 1 $tmax
  scalar Tadd = Tlocal - $nobs
  dataset addobs Tadd
endif
list L = matrix_to_list(m, cnameget(m), rnameget(m))
scalar err = store_list(L, filename, store_arguments)
return err
</code>
</gretl-function>
<gretl-function name="store_list" type="scalar" private="1">
 <params count="3">
  <param name="L" type="list" const="true"/>
  <param name="filename" type="string" const="true"/>
  <param name="store_arguments" type="string" const="true"/>
 </params>
<code>/* Store list of series. */
catch store &quot;@filename&quot; L @store_arguments
if $error
  printf &quot;\nError: Could not store file '%s'.\n&quot;, filename
  return 1
else
  return 0
endif
</code>
</gretl-function>
<gretl-function name="matrix_to_list" type="list" private="1">
 <params count="3">
  <param name="m" type="matrix" const="true"/>
  <param name="column_labels" type="strings" const="true"/>
  <param name="row_labels" type="strings" const="true"/>
 </params>
<code>/* Cast colum-vectors as series and put series to a list.
Name series accordingly to eventually existing column-labels.
In case row-labels exist, put another string-values series to
the list. */
list L = null
loop i=1..cols(m) -q
  list L += genseries(get_column_name(column_labels, $i), m[,i])
endloop
if nelem(row_labels) &gt; 0
  string vname = &quot;row_label&quot;
  #        series foo = get_str_valued_series(row_labels)			# FIXME:
  #        print foo -o
  #        stop
  list L += genseries(vname, get_str_valued_series(row_labels))
  #        print L -o
  #        stop
endif
return L
</code>
</gretl-function>
<gretl-function name="get_str_valued_series" type="series" private="1">
 <params count="1">
  <param name="S" type="strings" const="true"/>
 </params>
<code>/* Generate string-valued series comprising row labels. */
series y = map_uniq_str_to_int_series(S)
stringify(y, S)
return y
</code>
</gretl-function>
<gretl-function name="get_column_name" type="string" private="1">
 <params count="2">
  <param name="column_labels" type="strings" const="true"/>
  <param name="series_id" type="int" const="true"/>
 </params>
<code>/* Either retrieve matrix' column labels, or
generate a new series name. */
if nelem(column_labels) &gt; 0
  return sprintf(&quot;%s&quot;, column_labels[series_id])
else
  return sprintf(&quot;v%d&quot;, series_id)
endif
</code>
</gretl-function>
<gretl-function name="valid_matrix" type="scalar" private="1">
 <params count="1">
  <param name="m" type="matrix" const="true"/>
 </params>
<code>if rows(m) == 0 || cols(m) == 0
  printf &quot;\nError: Empty matrix provided.\n&quot;
  return 0
else
  return 1
endif
</code>
</gretl-function>
<gretl-function name="valid_filename" type="scalar" private="1">
 <params count="1">
  <param name="filename" type="string" const="true"/>
 </params>
<code>if strlen(filename) == 0
  printf &quot;\nError: Invalid filename.\n&quot;
  return 0
else
  return 1
endif
</code>
</gretl-function>
<gretl-function name="map_uniq_str_to_int_series" type="series" private="1">
 <params count="1">
  <param name="S" type="strings" const="true"/>
 </params>
<code>/* Get unique string-values of array. Map each unique string value
in S to a unique integer and store vector as series. */
strings suniq = struniq(S)
matrix m = NA * ones(1, $tmax)
series s = -1
if nelem(S) != $tmax
  printf &quot;\nError: Dimension of 'row_labels' must equal number of observations .\n&quot;
  return s
endif
loop i=1..$tmax -q
  m[i] = strpos(suniq, S[i])
endloop
series s = m
return s
</code>
</gretl-function>
<gretl-function name="strpos" type="matrix" private="1">
 <params count="3">
  <param name="S" type="strings" const="true">
<description>Array of strings</description>
  </param>
  <param name="str" type="string" const="true">
<description>String being searched for in S</description>
  </param>
  <param name="print_warnings" type="bool" default="1" const="true">
<description>Print eventual warnings</description>
  </param>
 </params>
<code># Returns the positional entries of string in S in a column vector
# if S contains string, 0 otherwise.
if nelem(S) == 0
  if print_warnings
    printf &quot;Warning: String array '%s' is empty.\n&quot;, argname(S)
  endif
  return {0}
endif
matrix ret = {}
loop i=1..nelem(S) -q
  if S[i] == str
    ret |= $i
  endif
endloop
if rows(ret) &gt; 0
  return ret
else
  return {0}
endif
</code>
</gretl-function>
<gretl-function name="struniq" type="strings" private="1">
 <params count="1">
  <param name="S" type="strings" const="true"/>
 </params>
<code>/* Returns an array containing the distinct elements
of S not sorted but in their order of appearance. */
strings suniq = defarray(S[1])
loop i=2..nelem(S) -q
  if strpos(suniq, S[i]) == 0		# TODO: What about empty strings?
    suniq += S[i]
  endif
endloop
return suniq
</code>
</gretl-function>
<sample-script>
set verbose off
clear

include MwriteCsv.gfn

scalar n_rows = 5
matrix m = mnormal(n_rows, 5)
cnameset(m, &quot;A B C D E&quot;)
strings rnam = array(n_rows)
loop i=1..n_rows -q
    rnam[i] = sprintf(&quot;R%d&quot;, $i)
endloop
rnameset(m, rnam)
m[1,1] = NA

MwriteCsv(m, &quot;foo.csv&quot;)

eval readfile(&quot;foo.csv&quot;)
open &quot;foo.csv&quot; -p -q
</sample-script>
</gretl-function-package>
</gretl-functions>
