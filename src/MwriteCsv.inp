function scalar MwriteCsv (const matrix m,
                           string filename "Path+filename",
                           const string store_arguments[null] "Options for 'store' command")

    if !valid_filename(filename) || !valid_matrix(m)
        return 1
    endif

#    string filename = add_non_existing_file_type(filename)	# TODO: still needed?
    if !exists(store_arguments)
        string store_arguments = ""
    endif

    # Addings obs cannot be put into a separate function (added obs would get lost)
    if Tlocal <= $tmax
        smpl 1 Tlocal
    else
        smpl 1 $tmax
        scalar Tadd = Tlocal - $nobs
        dataset addobs Tadd
    endif

    list L = matrix_to_list(m, cnameget(m), rnameget(m))

    scalar err = store_list(L, filename, store_arguments)

    return err
end function


function scalar store_list (const list L,
                            const string filename,
                            const string store_arguments)
    /* Store list of series. */

    catch store "@filename" L @store_arguments
    if $error
        printf "\nError: Could not store file '%s'.\n", filename
        return 1
    else
        return 0
    endif
end function


function list matrix_to_list (const matrix m,
                              const strings column_labels,
                              const strings row_labels)
    /* Cast colum-vectors as series and put series to a list.
       Name series accordingly to eventually existing column-labels.
       In case row-labels exist, put another string-values series to
    the list. */

    list L = null

    loop i=1..cols(m) -q
        list L += genseries(get_column_name(column_labels, $i), m[,i])
    endloop
    print L -o

    # TODO: tricky case!
    if nelem(row_labels) > 0
        #        string vname = "row_label"
        #        series @vname = stringify
        #        list L += genseries(vname, m[,i])
    endif

    return L
end function

function string get_row_name (const strings column_labels,
                                 const int series_id)
/* Either retrieve matrix' column labels, or
    generate a new series name. */
    

end function

function string get_column_name (const strings column_labels,
                                 const int series_id)
/* Either retrieve matrix' column labels, or
    generate a new series name. */

    if nelem(column_labels) > 0
        return sprintf("%s", column_labels[series_id])
    else
        return sprintf("v%d", series_id)
    endif
end function


function scalar valid_matrix (const matrix m)
    if rows(m) == 0 || cols(m) == 0
        printf "\nError: Empty matrix provided.\n"
        return 0
    else
        return 1
    endif
end function

# TODO: Still needed??
function scalar valid_filename (const string filename)
    if strlen(filename) == 0
        printf "\nError: Invalid filename.\n"
        return 0
    else
        return 1
    endif
end function


# Mapping from each unique string-value to a specific integer
# for whole series

function series map_uniq_str_to_series (const strings row_labels)

    strings suniq = struniq(row_labels)
    matrix m = NA * ones(1, $tmax)

    if nelem(row_labels) != $tmax
        printf "\nError: Dimension of row_labels must equal number of observations .\n"
    endif

    loop i=1..$tmax -q
        m[i] = strpos(suniq, row_labels[i])
    endloop
    *** HIER WEITERMACHEN ***
    series s = m
    
    return s
end function



# TODO: Will be part of extra.gfn in v0.51
function matrix strpos (const strings S "Array of strings",
                        const string str "String being searched for in S",
                        const bool print_warnings[1] "Print eventual warnings")
    # Returns the positional entries of string in S in a column vector
    # if S contains string, 0 otherwise.

    if nelem(S) == 0
        if print_warnings
            printf "Warning: String array '%s' is empty.\n", argname(S)
        endif
        return {0}
    endif

    matrix ret = {}
    loop i=1..nelem(S) -q
        if S[i] == str
            ret |= $i
        endif
    endloop

    if rows(ret) > 0
        return ret
    else
        return {0}
    endif
end function


function strings struniq (const strings S)
    /* Returns an array containing the distinct elements
    of S not sorted but in their order of appearance. */

    strings suniq = defarray(S[1])
    
    loop i=2..nelem(S) -q
        if strpos(suniq, S[i]) == 0
            suniq += S[i]
        endif
    endloop
    
    return suniq
end function
